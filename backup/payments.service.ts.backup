// Payments.Service.ts

import {
  Injectable,
  NotFoundException,
  BadRequestException,
  Logger,
  Inject,
  forwardRef,
} from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { ConfigService } from '@nestjs/config';
import Xendit from 'xendit-node';
import { Payment } from 'src/entities/payment.entity';
import { Order } from 'src/entities/order.entity';
import { CreatePaymentDto } from './dto/create-payment.dto';
import { PaymentWebhookDto } from './dto/payment-webhook.dto';
import { OrdersService } from '../orders/orders.service';
import { TicketsService } from '../tickets/tickets.service';
import { MailService } from 'src/mail/mail.service';

@Injectable()
export class PaymentsService {
  private readonly logger = new Logger(PaymentsService.name);
  private xenditClient: any;
  private  useMockMode: boolean;
  private readonly webhookToken: string;

  constructor(
    @InjectRepository(Payment)
    private readonly paymentRepository: Repository<Payment>,
    @InjectRepository(Order)
    private readonly orderRepository: Repository<Order>,
    @Inject(forwardRef(() => OrdersService))
    private readonly ordersService: OrdersService,
    private readonly ticketsService: TicketsService,
    private readonly configService: ConfigService,
    private readonly mailService: MailService,
  ) {
    const secretKey = this.configService.get<string>('xendit.secretKey') || '';
    this.webhookToken = this.configService.get<string>('xendit.webhookToken') || '';

    this.useMockMode = !secretKey || secretKey.includes('your_secret_key_here');

    if (this.useMockMode) {
      this.logger.warn('Running in MOCK MODE - Xendit integration disabled');
      this.logger.warn('Set XENDIT_SECRET_KEY in .env to enable real payments');
    } else {
      try {
        this.xenditClient = new Xendit({ secretKey });
        this.logger.log(' Xendit client initialized successfully');
        this.logger.log(`Webhook token configured: ${this.webhookToken ? 'Yes' : 'No'}`);
      } catch (error) {
        this.logger.error(`Failed to initialize Xendit: ${error.message}`);
        this.logger.error('Falling back to MOCK MODE');
        this.useMockMode = true;
      }
    }
  }

  private verifyWebhookSignature(callbackToken: string): boolean {
    if (this.useMockMode) return true;
    
    if (this.webhookToken && callbackToken === this.webhookToken) {
      return true;
    }

    this.logger.warn('Webhook verification failed');
    return false;
  }

  private generateReferenceId(): string {
    const date = new Date();
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    const random = Math.floor(Math.random() * 100000).toString().padStart(5, '0');

    return `PAY-${year}${month}${day}-${random}`;
  }

  private generateMockPaymentUrl(referenceId: string, method: string): string {
    const baseUrl = this.configService.get<string>('app.url') || 'http://localhost:3000';
    return `${baseUrl}/mock-payment/${referenceId}?method=${method}`;
  }

  private getPaymentMethods(method: string): string[] {
    const allMethods = [
      'CREDIT_CARD',
      'BCA',
      'BNI',
      'BRI',
      'MANDIRI',
      'PERMATA',
      'QRIS',
      'OVO',
      'DANA',
      'SHOPEEPAY',
      'LINKAJA',
      'ALFAMART',
      'INDOMARET',
    ];

    if (method && method !== 'various') {
      return [method.toUpperCase()];
    }
    return allMethods;
  }

  async create(createPaymentDto: CreatePaymentDto) {
    const { orderId, paymentMethod } = createPaymentDto;

    this.logger.log(`Creating payment for order: ${orderId}`);

    const order = await this.orderRepository.findOne({
      where: { id: orderId },
      relations: ['event', 'user', 'event.category'],
    });

    if (!order) {
      throw new NotFoundException(`Order with ID '${orderId}' not found`);
    }

    if (order.status !== 'pending' && order.status !== 'awaiting_payment') {
      throw new BadRequestException(
        `Cannot create payment for order with status '${order.status}'`,
      );
    }

    if (new Date() > new Date(order.expiredAt)) {
      order.status = 'expired';
      await this.orderRepository.save(order);
      throw new BadRequestException('Order has expired');
    }

    const existingPayment = await this.paymentRepository.findOne({
      where: { orderId },
    });

    if (existingPayment) {
      if (existingPayment.status === 'pending') {
        this.logger.log(`Payment already exists for order ${orderId}`);
        return {
          message: 'Payment already exists',
          payment: {
            id: existingPayment.id,
            referenceId: existingPayment.referenceId,
            paymentMethod: existingPayment.paymentMethod,
            amount: existingPayment.amount,
            status: existingPayment.status,
            paymentUrl: existingPayment.paymentUrl,
            isMock: this.useMockMode,
          },
        };
      } else {
        throw new BadRequestException(
          `Payment already exists with status: ${existingPayment.status}`,
        );
      }
    }

    const referenceId = this.generateReferenceId();

    let result: any;
    if (this.useMockMode) {
      result = await this.createMockPayment(
        order,
        referenceId,
        paymentMethod ?? 'various',
      );
    } else {
      result = await this.createXenditPayment(
        order,
        referenceId,
        paymentMethod ?? 'various',
      );
    }

    try {
      await this.mailService.sendOrderCreatedEmail({
        email: order.user.email,
        userName: order.user.name || order.user.email,
        orderNumber: order.orderNumber,
        invoiceNumber: order.invoiceNumber,
        eventTitle: (order.event as any).title,
        quantity: order.quantity,
        totalAmount: order.totalAmount,
        expiredAt: order.expiredAt,
        paymentUrl: result.payment.paymentUrl,
      });
      this.logger.log(`Order confirmation email sent to ${order.user.email}`);
    } catch (error) {
      this.logger.error(`Failed to send order email: ${error.message}`);
    }

    return result;
  }

  private async createMockPayment(
    order: Order,
    referenceId: string,
    paymentMethod: string,
  ) {
    this.logger.log(`Creating mock payment: ${referenceId}`);

    const paymentUrl = this.generateMockPaymentUrl(referenceId, paymentMethod);

    const payment = this.paymentRepository.create({
      orderId: order.id,
      provider: 'xendit',
      paymentMethod,
      referenceId,
      amount: order.totalAmount,
      status: 'pending',
      paymentUrl,
      metadata: {
        orderNumber: order.orderNumber,
        eventTitle: (order.event as any)?.title,
        quantity: order.quantity,
        mockPayment: true,
        instructions: 'This is a mock payment. Use /payments/simulate endpoint to complete payment.',
      },
    });

    const savedPayment = await this.paymentRepository.save(payment);

    this.logger.log(`Mock payment created: ${savedPayment.referenceId}`);

    return {
      message: 'Payment created successfully (Mock Mode)',
      payment: {
        id: savedPayment.id,
        referenceId: savedPayment.referenceId,
        paymentMethod: savedPayment.paymentMethod,
        amount: savedPayment.amount,
        status: savedPayment.status,
        paymentUrl: savedPayment.paymentUrl,
        expiresAt: order.expiredAt,
        isMock: true,
        instructions: [
          'This is a MOCK payment for testing',
          `âœ“ Use POST /payments/simulate/${savedPayment.referenceId}?status=PAID to complete payment`,
          `âœ— Or use POST /payments/simulate/${savedPayment.referenceId}?status=FAILED to fail payment`,
        ],
      },
    };
  }

  private async createXenditPayment(
    order: Order,
    referenceId: string,
    paymentMethod: string,
  ) {
    try {
      const { Invoice } = this.xenditClient;

      const expiryDate = new Date();
      expiryDate.setHours(expiryDate.getHours() + 24);

      const adminFee = this.configService.get<number>('xendit.adminFee') || 5000;
      const totalWithFee = order.totalAmount + adminFee;

      this.logger.debug(`Creating Xendit invoice for order ${order.id}`);
      this.logger.debug(`Amount: ${totalWithFee} (${order.totalAmount} + ${adminFee} admin fee)`);
      this.logger.debug(`Email: ${order.user.email}`);

      const invoicePayload = {
        externalId: referenceId,
        amount: totalWithFee,
        payerEmail: order.user.email,
        description: `Pembayaran tiket ${(order.event as any).title}`,
        invoiceDuration: 86400, 
        successRedirectUrl: this.configService.get('xendit.successRedirectUrl'),
        failureRedirectUrl: this.configService.get('xendit.failureRedirectUrl'),
        currency: 'IDR',
        items: [
          {
            name: (order.event as any).title,
            quantity: order.quantity,
            price: Number(order.unitPrice),
            category: (order.event as any).category?.name || 'Event',
          },
        ],
        customer: {
          givenNames: order.user.name || 'Customer',
          email: order.user.email,
          mobileNumber: (order.user as any).phone || '+6281234567890',
        },
        fees: [
          {
            type: 'Admin Fee',
            value: adminFee,
          },
        ],
      };

      const invoice = await Invoice.createInvoice({
        data: invoicePayload,
      });

      this.logger.log(`Xendit Invoice created: ${invoice.id}`);
      this.logger.log(`Payment URL: ${invoice.invoice_url}`);
      this.logger.log(`Expires at: ${invoice.expiry_date}`);

      const payment = this.paymentRepository.create({
        orderId: order.id,
        provider: 'xendit',
        paymentMethod: paymentMethod || 'various',
        referenceId,
        amount: order.totalAmount,
        status: 'pending',
        paymentUrl: invoice.invoice_url,
        metadata: {
          xenditInvoiceId: invoice.id,
          orderNumber: order.orderNumber,
          eventTitle: (order.event as any).title,
          quantity: order.quantity,
          adminFee,
          totalWithFee,
        },
      });

      const savedPayment = await this.paymentRepository.save(payment);

      this.logger.log(`Payment saved to DB: ${savedPayment.id}`);

      return {
        message: 'Payment created successfully',
        payment: {
          id: savedPayment.id,
          referenceId: savedPayment.referenceId,
          paymentMethod: savedPayment.paymentMethod,
          amount: savedPayment.amount,
          adminFee,
          totalWithFee,
          status: savedPayment.status,
          paymentUrl: savedPayment.paymentUrl,
          expiresAt: expiryDate,
          isMock: false,
          xenditInvoiceId: invoice.id,
        },
      };
    } catch (error) {
      this.logger.error(`Failed to create Xendit invoice: ${error.message}`);

      if (error.response?.data) {
        this.logger.error(`Xendit Error Details: ${JSON.stringify(error.response.data)}`);
      }

      this.logger.error(`Stack trace: ${error.stack}`);

      throw new BadRequestException(
        `Failed to create payment: ${error.message || 'Unknown error'}`,
      );
    }
  }

  async handleWebhook(webhookDto: PaymentWebhookDto, callbackToken?: string) {
    const externalId = webhookDto.external_id || webhookDto.externalId;
    
    const {
      id,
      user_id,
      status,
      amount,
      paid_amount,
      bank_code,
      paid_at,
      payer_email,
      description,
      payment_channel,
      payment_method,
      currency,
      payment_destination,
      is_high,
      merchant_name,
      adjusted_received_amount,
      fees_paid_amount,
      updated,
      created,
    } = webhookDto as any;

    this.logger.log(`ðŸ“¨ Webhook received: ${externalId} - Status: ${status}`);
    this.logger.debug(`Full webhook data: ${JSON.stringify(webhookDto)}`);
    this.logger.debug(`Payment method: ${payment_method} via ${payment_channel}`);

    if (!this.verifyWebhookSignature(callbackToken ?? '')) {
      this.logger.error('âŒ Invalid webhook signature');
      throw new BadRequestException('Invalid webhook signature');
    }

    const payment = await this.paymentRepository.findOne({
      where: { referenceId: externalId },
      relations: ['order', 'order.event', 'order.user'],
    });

    if (!payment) {
      this.logger.error(`âŒ Payment not found: ${externalId}`);
      throw new NotFoundException('Payment not found');
    }

    if (payment.status === status.toLowerCase()) {
      this.logger.warn(`âš ï¸ Payment ${externalId} already processed with status ${status}`);
      return {
        message: 'Webhook already processed',
        payment: {
          id: payment.id,
          referenceId: payment.referenceId,
          status: payment.status,
        },
      };
    }

    const oldStatus = payment.status;
    payment.status = status.toLowerCase();

    payment.metadata = {
      ...payment.metadata,
      xenditInvoiceId: id,
      userId: user_id,
      paidAmount: paid_amount,
      bankCode: bank_code,
      paymentChannel: payment_channel,
      paymentDestination: payment_destination,
      merchantName: merchant_name,
      adjustedReceivedAmount: adjusted_received_amount,
      feesPaidAmount: fees_paid_amount,
      isHigh: is_high,
    };

    if (status === 'PAID') {
      await this.handlePaidPayment(payment, paid_at);
    } else if (status === 'EXPIRED' || status === 'FAILED') {
      await this.handleFailedPayment(payment, status);
    }

    await this.paymentRepository.save(payment);

    this.logger.log(`âœ“ Payment status updated: ${oldStatus} â†’ ${payment.status}`);

    return {
      message: 'Payment status updated',
      payment: {
        id: payment.id,
        referenceId: payment.referenceId,
        oldStatus,
        newStatus: payment.status,
        paidAt: payment.paidAt,
        xenditData: {
          invoiceId: id,
          bankCode: bank_code,
          paymentChannel: payment_channel,
          paidAmount: paid_amount,
          paymentDestination: payment_destination,
        },
      },
    };
  }

  private async handlePaidPayment(payment: Payment, paidAt?: string) {
    payment.paidAt = paidAt ? new Date(paidAt) : new Date();

    this.logger.log(`ðŸ’° Processing paid payment: ${payment.referenceId}`);
    this.logger.log(`Paid at: ${payment.paidAt.toISOString()}`);

    const order = await this.orderRepository.findOne({
      where: { id: payment.orderId },
      relations: ['event', 'user', 'tickets'],
    });

    if (!order) {
      this.logger.error(`Order not found: ${payment.orderId}`);
      return;
    }

    order.status = 'paid';
    await this.orderRepository.save(order);
    this.logger.log(`âœ“ Order ${order.orderNumber} marked as paid`);

    try {
      const tickets = await this.ticketsService.generateTicketsForOrder(order.id);
      this.logger.log(`Generated ${tickets.length} tickets for order ${order.id}`);
    } catch (error) {
      this.logger.error(`Error generating tickets: ${error.message}`);
    }

    try {
      await this.mailService.sendOrderPaidEmail({
        email: order.user.email,
        userName: order.user.name || order.user.email,
        orderNumber: order.orderNumber,
        invoiceNumber: order.invoiceNumber,
        eventTitle: (order.event as any).title,
        eventLocation: (order.event as any).location,
        eventStartTime: (order.event as any).startTime || (order.event as any).eventDate,
        quantity: order.quantity,
        totalAmount: order.totalAmount,
        paidAt: payment.paidAt,
        paymentMethod: payment.paymentMethod || 'Unknown',
        tickets: order.tickets?.map((t: any) => ({
          id: t.id,
          ticketNumber: t.id,
          qrCodeUrl: t.qrCodeUrl,
          pdfUrl: t.pdfUrl,
        })),
      });

      this.logger.log(`Payment confirmation email sent to ${order.user.email}`);
    } catch (error) {
      this.logger.error(`Failed to send payment email: ${error.message}`);
    }

    this.logger.log(`Payment ${payment.referenceId} fully processed`);
  }

  private async handleFailedPayment(payment: Payment, status: string) {
    this.logger.log(`Processing failed payment: ${payment.referenceId} (${status})`);

    payment.status = 'failed';

    await this.ordersService.updateStatus(payment.orderId, 'expired');

    const order = await this.orderRepository.findOne({
      where: { id: payment.orderId },
      relations: ['event', 'user'],
    });

    if (order?.event) {
      const eventRepo = this.orderRepository.manager.getRepository('Event');
      const event = await eventRepo.findOne({
        where: { id: order.event.id },
      });

      if (event && 'quota' in event) {
        (event as any).quota += order.quantity;
        await eventRepo.save(event);
        this.logger.log(`Restored ${order.quantity} quota to event ${order.event.id}`);
      }
    }

    if (order) {
      try {
        await this.mailService.sendOrderExpiredEmail({
          email: order.user.email,
          userName: order.user.name || order.user.email,
          orderNumber: order.orderNumber,
          eventTitle: (order.event as any).title,
        });

        this.logger.log(`Expiry email sent to ${order.user.email}`);
      } catch (error) {
        this.logger.error(`Failed to send expiry email: ${error.message}`);
      }
    }

    this.logger.log(`Payment ${payment.referenceId} marked as ${status}`);
  }

  async findByOrderId(orderId: string) {
    const payment = await this.paymentRepository.findOne({
      where: { orderId },
      relations: ['order', 'order.event', 'order.user'],
    });

    if (!payment) {
      throw new NotFoundException('Payment not found for this order');
    }

    return {
      id: payment.id,
      referenceId: payment.referenceId,
      provider: payment.provider,
      paymentMethod: payment.paymentMethod,
      amount: payment.amount,
      status: payment.status,
      paymentUrl: payment.paymentUrl,
      paidAt: payment.paidAt,
      createdAt: payment.createdAt,
      isMock: this.useMockMode,
      metadata: payment.metadata,
      order: {
        id: payment.order.id,
        orderNumber: payment.order.orderNumber,
        status: payment.order.status,
        quantity: payment.order.quantity,
        totalAmount: payment.order.totalAmount,
      },
    };
  }

  async findByReferenceId(referenceId: string) {
    const payment = await this.paymentRepository.findOne({
      where: { referenceId },
      relations: ['order', 'order.event', 'order.user'],
    });

    if (!payment) {
      throw new NotFoundException('Payment not found');
    }

    return payment;
  }

  async simulatePayment(referenceId: string, status: 'PAID' | 'FAILED' | 'EXPIRED') {
    if (!this.useMockMode) {
      throw new BadRequestException('Simulate payment only available in mock mode');
    }

    this.logger.log(`ðŸŽ­ Simulating payment: ${referenceId} - Status: ${status}`);

    return this.handleWebhook({
      external_id: referenceId,
      externalId: referenceId,
      status,
      amount: 0,
      paymentMethod: 'simulation',
    });
  }

  async checkPaymentStatus(referenceId: string) {
    if (this.useMockMode) {
      throw new BadRequestException('Check payment status not available in mock mode');
    }

    try {
      const { Invoice } = this.xenditClient;
      const payment = await this.findByReferenceId(referenceId);

      const xenditInvoiceId = payment.metadata?.xenditInvoiceId;

      if (!xenditInvoiceId) {
        throw new BadRequestException('Xendit invoice ID not found');
      }

      this.logger.log(`Checking payment status: ${referenceId}`);

      const invoice = await Invoice.getInvoice({ invoiceId: xenditInvoiceId });

      return {
        referenceId: payment.referenceId,
        status: invoice.status.toLowerCase(),
        amount: invoice.amount,
        paidAt: invoice.paid_at,
        paymentMethod: invoice.payment_method,
        xenditData: invoice,
      };
    } catch (error) {
      this.logger.error(`Failed to check payment status: ${error.message}`);
      throw new BadRequestException('Failed to check payment status');
    }
  }

  async expireInvoice(referenceId: string) {
    if (this.useMockMode) {
      throw new BadRequestException('Expire invoice not available in mock mode');
    }

    try {
      const payment = await this.findByReferenceId(referenceId);

      const xenditInvoiceId = payment.metadata?.xenditInvoiceId;
      if (!xenditInvoiceId) {
        throw new BadRequestException('Xendit invoice ID not found');
      }

      this.logger.log(`Expiring invoice: ${referenceId}`);

      const { Invoice } = this.xenditClient;

      const invoice = await Invoice.expireInvoice({
        invoiceId: xenditInvoiceId,
      });

      payment.status = 'expired';
      await this.paymentRepository.save(payment);

      await this.ordersService.updateStatus(payment.orderId, 'expired');

      this.logger.log(`Invoice expired: ${xenditInvoiceId}`);

      return {
        message: 'Invoice expired successfully',
        payment: {
          referenceId: payment.referenceId,
          status: payment.status,
          xenditInvoiceId,
        },
      };
    } catch (error) {
      this.logger.error(`Failed to expire invoice: ${error.message}`);
      throw new BadRequestException('Failed to expire invoice');
    }
  }
}
